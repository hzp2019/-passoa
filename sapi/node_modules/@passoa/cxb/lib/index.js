"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs-extra");
var url = require("url");
var path = require("path");
var cp = require("child_process");
var dist_1 = require("./dist");
var environment = require("./environment");
var downloader_1 = require("./downloader");
var util_1 = require("util");
var uploader_1 = require("./uploader");
var dist = new dist_1.Dist();
var downloader = new downloader_1.Downloader({});
process.on('unhandledRejection', function (error) {
    console.error('unhandledRejection', error);
    process.exit(1); // To exit with a 'failure' code
});
function initConfig() {
    var pkg = require(process.cwd() + "/package.json");
    var env = process.env;
    var config = {
        name: pkg.name,
        configuration: env.build_type || 'Release',
        external: [],
        version: pkg.version,
        platform: plat_format(env.platform || process.platform),
        arch: arch_format(env.arch || process.arch),
        build_cmd: [],
        toolset_path: env.toolset_path || '',
        make_path: env.make_path || 'make',
        module_name: pkg.name,
        module_path: 'build',
        remote_path: 'repertory/cxb/',
        package_name: '',
        host: '',
        hosted_path: '',
        hosted_tarball: '',
        staged_tarball: '',
        method: 'put',
        form: false,
        root_dir: process.cwd()
    };
    var opts = require(config.root_dir + "/cxb.config.js")(config);
    mergeConfig(config, opts);
    config.hosted_path = url.resolve(config.host, config.remote_path);
    config.hosted_tarball = url.resolve(config.hosted_path, config.package_name);
    return config;
}
exports.initConfig = initConfig;
function mergeConfig(config, opts) {
    for (var key in opts) {
        if (opts.hasOwnProperty(key) && config.hasOwnProperty(key)) {
            config[key] = opts[key];
        }
    }
}
function run(argv) {
    return __awaiter(this, void 0, void 0, function () {
        var config, cwd, r;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dist.ensureDownloaded()];
                case 1:
                    _a.sent();
                    if (usage(argv))
                        return [2 /*return*/, -1];
                    config = initConfig();
                    if (!(argv.b || argv.build)) return [3 /*break*/, 3];
                    return [4 /*yield*/, build(config)];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 12];
                case 3:
                    if (!(argv.i || argv.install)) return [3 /*break*/, 7];
                    cwd = process.cwd();
                    r = cwd.indexOf('node_modules');
                    if (!(r < 0)) return [3 /*break*/, 4];
                    console.log('donot install when process.cwd in this project!!!');
                    return [2 /*return*/, 0];
                case 4: return [4 /*yield*/, install(config)];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6: return [3 /*break*/, 12];
                case 7:
                    if (!(argv.p || argv.pack)) return [3 /*break*/, 9];
                    return [4 /*yield*/, pack(config)];
                case 8:
                    _a.sent();
                    return [3 /*break*/, 12];
                case 9:
                    if (!(argv.r || argv.release)) return [3 /*break*/, 11];
                    return [4 /*yield*/, release(config)];
                case 10:
                    _a.sent();
                    return [3 /*break*/, 12];
                case 11:
                    console.log('cxb: show help with --help');
                    return [2 /*return*/, -2];
                case 12: return [2 /*return*/, 0];
            }
        });
    });
}
exports.run = run;
function usage(argv) {
    var help = argv.h || argv.help;
    if (help) {
        // If they didn't ask for help, then this is not a "success"
        var log = help ? console.log : console.error;
        log('Usage: pm <modules> [<Options> ...]');
        log('');
        log('  install native modules@passoa');
        log('');
        log('Options:');
        log('');
        log('  -h, --help     Display this usage info');
        log('  -b, --build   build cpp for project');
        log('  -r, --release   release node tgz for project');
        log('  -i, --install   install cpp module(it will build cpp module if could not download from remote)');
        return -1;
    }
    return 0;
}
function eval_template(template, opts) {
    template = template.replace(/\{([a-zA-Z0-9_-]+)\}/g, function (str) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var key = opts[args[0]] || process.env[args[0]] || 'undefined';
        return key;
    });
    // Object.keys(opts).forEach(function(key) {
    // 	var pattern = '{' + key + '}';
    // 	while (template.indexOf(pattern) > -1) {
    // 		template = template.replace(pattern, opts[key]);
    // 	}
    // });
    return template;
}
// url.resolve needs single trailing slash
// to behave correctly, otherwise a double slash
// may end up in the url which breaks requests
// and a lacking slash may not lead to proper joining
function fix_slashes(pathname) {
    if (pathname.slice(-1) != '/') {
        return pathname + '/';
    }
    return pathname;
}
// remove double slashes
// note: path.normalize will not work because
// it will convert forward to back slashes
function drop_double_slashes(pathname) {
    return pathname.replace(/\/\//g, '/');
}
function plat_format(plat) {
    switch (plat) {
        case 'win32':
        case 'windows':
            return 'windows';
    }
    return plat;
}
function arch_format(arch) {
    switch (arch) {
        case 'ia32':
        case 'x32':
        case 'x86':
            return 'x86';
        case 'x86_64':
        case 'x64':
            return 'x64';
    }
    return arch;
}
function isStringArray(arr) {
    var e_1, _a;
    try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var iterator = arr_1_1.value;
            if (typeof iterator != 'string')
                return false;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
}
function isStringArray2(arr) {
    var e_2, _a;
    try {
        for (var arr_2 = __values(arr), arr_2_1 = arr_2.next(); !arr_2_1.done; arr_2_1 = arr_2.next()) {
            var iterator = arr_2_1.value;
            if (!Array.isArray(iterator) && !isStringArray(iterator))
                return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arr_2_1 && !arr_2_1.done && (_a = arr_2.return)) _a.call(arr_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
function addDefaultCmd(bc, config) {
    var incPaths;
    if (dist.headerOnly) {
        incPaths = [path.join(dist.internalPath, '/include/node')];
    }
    else {
        var nodeH = path.join(dist.internalPath, '/src');
        var v8H = path.join(dist.internalPath, '/deps/v8/include');
        var uvH = path.join(dist.internalPath, '/deps/uv/include');
        incPaths = [nodeH, v8H, uvH];
    }
    // Includes:
    bc.push("-DCMAKE_JS_INC=" + incPaths.join(';'));
    if (environment.isWin) {
        // Win
        var libs = dist.winLibs;
        if (libs.length) {
            bc.push("-DCMAKE_JS_LIB=" + libs.join(';'));
        }
    }
    bc.push("-DCXB_MODULE_DIST=" + config.root_dir + "/" + config.module_path);
}
function buildByStringArray(build_str, config, bc) {
    for (var key in bc) {
        if (bc.hasOwnProperty(key)) {
            var element = bc[key];
            bc[key] = eval_template(element, config);
        }
    }
    fs.emptyDirSync("tmp/" + build_str);
    process.chdir("tmp/" + build_str);
    bc = ['../../'].concat(bc);
    addDefaultCmd(bc, config);
    console.log(bc);
    var r = cp.spawnSync('cmake', bc, { stdio: 'inherit' });
    if (r.status) {
        throw new Error('cmake generator fails');
    }
    r = cp.spawnSync('cmake', ['--build', './', '--config', config.configuration], { stdio: 'inherit' });
    if (r.status) {
        throw new Error('cmake build fails');
    }
    process.chdir('../../');
}
function build(config) {
    return __awaiter(this, void 0, void 0, function () {
        var task1, task2, key, obj, urlstring, pathname, tmp, dst, build_str, bc, idx, bc_1, bc_1_1, iterator;
        var e_3, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!config.external) return [3 /*break*/, 3];
                    task1 = new Array(), task2 = new Array();
                    for (key in config.external) {
                        if (config.external.hasOwnProperty(key)) {
                            obj = config.external[key];
                            urlstring = '';
                            if (util_1.isArray(obj)) {
                                urlstring = obj[0];
                            }
                            else if (util_1.isString(obj)) {
                                urlstring = obj;
                            }
                            else {
                                throw new Error('cxb.external config has error');
                            }
                            pathname = url.parse(urlstring).pathname;
                            if (!pathname)
                                throw new Error('cxb.external config has error:' + pathname);
                            tmp = config.root_dir + "/tmp/stage/" + key + "/" + path.basename(pathname);
                            dst = path.join(config.root_dir + "/3rd", key);
                            if (fs.existsSync(dst)) {
                                break;
                            }
                            console.log(urlstring, tmp);
                            task1.push({ src: urlstring, dst: tmp });
                            task2.push({ src: tmp, dst: dst, option: { strip: obj[1] } });
                        }
                    }
                    return [4 /*yield*/, downloader.downloadAll(task1)];
                case 1:
                    _b.sent();
                    return [4 /*yield*/, downloader.unzipAll(task2)];
                case 2:
                    _b.sent();
                    _b.label = 3;
                case 3:
                    if (config.build_cmd) {
                        build_str = config.platform + "_" + config.arch;
                        bc = config.build_cmd[build_str];
                        if (!bc) {
                            throw new Error("please check your config for " + build_str);
                        }
                        if (Array.isArray(bc)) {
                            if (isStringArray(bc)) {
                                buildByStringArray(build_str, config, bc);
                            }
                            else if (isStringArray2(bc)) {
                                idx = 0;
                                try {
                                    for (bc_1 = __values(bc), bc_1_1 = bc_1.next(); !bc_1_1.done; bc_1_1 = bc_1.next()) {
                                        iterator = bc_1_1.value;
                                        buildByStringArray(build_str + "_" + idx++, config, iterator);
                                    }
                                }
                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                finally {
                                    try {
                                        if (bc_1_1 && !bc_1_1.done && (_a = bc_1.return)) _a.call(bc_1);
                                    }
                                    finally { if (e_3) throw e_3.error; }
                                }
                            }
                            else {
                                throw new Error("please check your config for " + build_str);
                            }
                        }
                    }
                    else {
                        throw new Error('build_cmd has not in cxb.config.js');
                    }
                    return [2 /*return*/, 0];
            }
        });
    });
}
exports.build = build;
function install(config) {
    return __awaiter(this, void 0, void 0, function () {
        var tarball, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tarball = config.module_name + "-v" + config.version + "-" + config.platform + "-" + config.arch + ".tar.gz";
                    config.staged_tarball = path.join('tmp/stage', tarball);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 4, , 5]);
                    return [4 /*yield*/, downloader.downloadAll([{ src: config.hosted_tarball, dst: config.staged_tarball }])];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, downloader.unzipAll([{ src: config.staged_tarball, dst: './' }])];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    err_1 = _a.sent();
                    console.log(config.hosted_tarball);
                    console.log(err_1.message);
                    return [2 /*return*/, build(config)];
                case 5: return [2 /*return*/, 0];
            }
        });
    });
}
exports.install = install;
function release(config) {
    return __awaiter(this, void 0, void 0, function () {
        var up, src, env;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    up = new uploader_1.Uploader();
                    src = path.join(config.root_dir, config.module_path);
                    config.staged_tarball = path.join(config.root_dir, "tmp/" + config.module_name + ".tar.gz");
                    return [4 /*yield*/, up.packTgz(src, config.staged_tarball)];
                case 1:
                    _a.sent();
                    env = process.env;
                    config.token = Buffer.from(env.CXBUSERNAME + ":" + env.CXBPASSWORD, 'utf8').toString('base64');
                    return [4 /*yield*/, up.upload(config.hosted_tarball, config.staged_tarball, config.token, {
                            method: config.method,
                            form: config.form
                        })];
                case 2:
                    _a.sent();
                    return [2 /*return*/, 0];
            }
        });
    });
}
exports.release = release;
function pack(config) {
    return __awaiter(this, void 0, void 0, function () {
        var up, src;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    up = new uploader_1.Uploader();
                    src = path.join(config.root_dir, config.module_path);
                    config.staged_tarball = path.join(config.root_dir, "tmp/" + config.module_name + ".tar.gz");
                    return [4 /*yield*/, up.packTgz(src, config.staged_tarball)];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
exports.pack = pack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZCQUErQjtBQUUvQix5QkFBMkI7QUFDM0IsMkJBQTZCO0FBQzdCLGtDQUFvQztBQUNwQywrQkFBOEI7QUFDOUIsMkNBQTZDO0FBQzdDLDJDQUFnRDtBQUNoRCw2QkFBeUM7QUFDekMsdUNBQXNDO0FBQ3RDLElBQUksSUFBSSxHQUFHLElBQUksV0FBSSxFQUFFLENBQUM7QUFDdEIsSUFBSSxVQUFVLEdBQUcsSUFBSSx1QkFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBMEJwQyxPQUFPLENBQUMsRUFBRSxDQUFDLG9CQUFvQixFQUFFLFVBQUMsS0FBSztJQUN0QyxPQUFPLENBQUMsS0FBSyxDQUFDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzNDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxnQ0FBZ0M7QUFDbEQsQ0FBQyxDQUFDLENBQUM7QUFFSCxTQUFnQixVQUFVO0lBQ3pCLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBSSxPQUFPLENBQUMsR0FBRyxFQUFFLGtCQUFlLENBQUMsQ0FBQztJQUNyRCxJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ3RCLElBQUksTUFBTSxHQUFHO1FBQ1osSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJO1FBQ2QsYUFBYSxFQUFFLEdBQUcsQ0FBQyxVQUFVLElBQUksU0FBUztRQUMxQyxRQUFRLEVBQUUsRUFBRTtRQUNaLE9BQU8sRUFBRSxHQUFHLENBQUMsT0FBTztRQUNwQixRQUFRLEVBQUUsV0FBVyxDQUFDLEdBQUcsQ0FBQyxRQUFRLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQztRQUN2RCxJQUFJLEVBQUUsV0FBVyxDQUFDLEdBQUcsQ0FB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QUFDLFdBQVcsU0FBSSxHQUFHLENBQUMsV0FBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDL0YscUJBQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxjQUFjLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRTs0QkFDM0UsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNOzRCQUNyQixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7eUJBQ2pCLENBQUMsRUFBQTs7b0JBSEYsU0FHRSxDQUFDO29CQUNILHNCQUFPLENBQUMsRUFBQzs7OztDQUNUO0FBWkQsMEJBWUM7QUFDRCxTQUFzQixJQUFJLENBQUMsTUFBb0I7Ozs7OztvQkFDMUMsRUFBRSxHQUFHLElBQUksbUJBQVEsRUFBRSxDQUFDO29CQUNwQixHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDekQsTUFBTSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBTyxNQUFNLENBQUMsV0FBVyxZQUFTLENBQUMsQ0FBQztvQkFDaEYscUJBQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFBO3dCQUFuRCxzQkFBTyxTQUE0QyxFQUFDOzs7O0NBQ3BEO0FBTEQsb0JBS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XHJcblxyXG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0ICogYXMgY3AgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XHJcbmltcG9ydCB7IERpc3QgfSBmcm9tICcuL2Rpc3QnO1xyXG5pbXBvcnQgKiBhcyBlbnZpcm9ubWVudCBmcm9tICcuL2Vudmlyb25tZW50JztcclxuaW1wb3J0IHsgRG93bmxvYWRlciwgaWZLeSB9IGZyb20gJy4vZG93bmxvYWRlcic7XHJcbmltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nIH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7IFVwbG9hZGVyIH0gZnJvbSAnLi91cGxvYWRlcic7XHJcbmxldCBkaXN0ID0gbmV3IERpc3QoKTtcclxubGV0IGRvd25sb2FkZXIgPSBuZXcgRG93bmxvYWRlcih7fSk7XHJcblxyXG5pbnRlcmZhY2UgQ29uZmlnT2JqZWN0IHtcclxuXHRuYW1lOiBzdHJpbmc7XHJcblx0Y29uZmlndXJhdGlvbjogc3RyaW5nO1xyXG5cdGV4dGVybmFsOiBhbnlbXTtcclxuXHR2ZXJzaW9uOiBzdHJpbmc7XHJcblx0cGxhdGZvcm06IHN0cmluZztcclxuXHRhcmNoOiBzdHJpbmc7XHJcblx0YnVpbGRfY21kOiBhbnk7XHJcblx0dG9vbHNldF9wYXRoOiBzdHJpbmc7XHJcblx0bWFrZV9wYXRoOiBzdHJpbmc7XHJcblx0bW9kdWxlX25hbWU6IHN0cmluZztcclxuXHRtb2R1bGVfcGF0aDogc3RyaW5nO1xyXG5cdHJlbW90ZV9wYXRoOiBzdHJpbmc7XHJcblx0cGFja2FnZV9uYW1lOiBzdHJpbmc7XHJcblx0aG9zdDogc3RyaW5nO1xyXG5cdGhvc3RlZF9wYXRoOiBzdHJpbmc7XHJcblx0aG9zdGVkX3RhcmJhbGw6IHN0cmluZztcclxuXHRzdGFnZWRfdGFyYmFsbDogc3RyaW5nO1xyXG5cdHJvb3RfZGlyOiBzdHJpbmc7XHJcblx0bWV0aG9kOiBzdHJpbmc7XHJcblx0Zm9ybTogYm9vbGVhbjtcclxuXHRba2V5OiBzdHJpbmddOiBhbnk7XHJcbn1cclxuXHJcbnByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIChlcnJvcikgPT4ge1xyXG5cdGNvbnNvbGUuZXJyb3IoJ3VuaGFuZGxlZFJlamVjdGlvbicsIGVycm9yKTtcclxuXHRwcm9jZXNzLmV4aXQoMSk7IC8vIFRvIGV4aXQgd2l0aCBhICdmYWlsdXJlJyBjb2RlXHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRDb25maWcoKTogQ29uZmlnT2JqZWN0IHtcclxuXHRjb25zdCBwa2cgPSByZXF1aXJlKGAke3Byb2Nlc3MuY3dkKCl9L3BhY2thZ2UuanNvbmApO1xyXG5cdGxldCBlbnYgPSBwcm9jZXNzLmVudjtcclxuXHRsZXQgY29uZmlnID0ge1xyXG5cdFx0bmFtZTogcGtnLm5hbWUsXHJcblx0XHRjb25maWd1cmF0aW9uOiBlbnYuYnVpbGRfdHlwZSB8fCAnUmVsZWFzZScsXHJcblx0XHRleHRlcm5hbDogW10sXHJcblx0XHR2ZXJzaW9uOiBwa2cudmVyc2lvbixcclxuXHRcdHBsYXRmb3JtOiBwbGF0X2Zvcm1hdChlbnYucGxhdGZvcm0gfHwgcHJvY2Vzcy5wbGF0Zm9ybSksXHJcblx0XHRhcmNoOiBhcmNoX2Zvcm1hdChlbnYuYXJjaCB8fCBwcm9jZXNzLmFyY2gpLFxyXG5cdFx0YnVpbGRfY21kOiBbXSxcclxuXHRcdHRvb2xzZXRfcGF0aDogZW52LnRvb2xzZXRfcGF0aCB8fCAnJyxcclxuXHRcdG1ha2VfcGF0aDogZW52Lm1ha2VfcGF0aCB8fCAnbWFrZScsXHJcblx0XHRtb2R1bGVfbmFtZTogcGtnLm5hbWUsXHJcblx0XHRtb2R1bGVfcGF0aDogJ2J1aWxkJyxcclxuXHRcdHJlbW90ZV9wYXRoOiAncmVwZXJ0b3J5L2N4Yi8nLFxyXG5cdFx0cGFja2FnZV9uYW1lOiAnJyxcclxuXHRcdGhvc3Q6ICcnLFxyXG5cdFx0aG9zdGVkX3BhdGg6ICcnLFxyXG5cdFx0aG9zdGVkX3RhcmJhbGw6ICcnLFxyXG5cdFx0c3RhZ2VkX3RhcmJhbGw6ICcnLFxyXG5cdFx0bWV0aG9kOiAncHV0JyxcclxuXHRcdGZvcm06IGZhbHNlLFxyXG5cdFx0cm9vdF9kaXI6IHByb2Nlc3MuY3dkKClcclxuXHR9O1xyXG5cclxuXHRjb25zdCBvcHRzOiBDb25maWdPYmplY3QgPSByZXF1aXJlKGAke2NvbmZpZy5yb290X2Rpcn0vY3hiLmNvbmZpZy5qc2ApKGNvbmZpZyk7XHJcblx0bWVyZ2VDb25maWcoY29uZmlnLCBvcHRzKTtcclxuXHRjb25maWcuaG9zdGVkX3BhdGggPSB1cmwucmVzb2x2ZShjb25maWcuaG9zdCwgY29uZmlnLnJlbW90ZV9wYXRoKTtcclxuXHRjb25maWcuaG9zdGVkX3RhcmJhbGwgPSB1cmwucmVzb2x2ZShjb25maWcuaG9zdGVkX3BhdGgsIGNvbmZpZy5wYWNrYWdlX25hbWUpO1xyXG5cdHJldHVybiBjb25maWc7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnOiBDb25maWdPYmplY3QsIG9wdHM6IENvbmZpZ09iamVjdCkge1xyXG5cdGZvciAoY29uc3Qga2V5IGluIG9wdHMpIHtcclxuXHRcdGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkgJiYgY29uZmlnLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0Y29uZmlnW2tleV0gPSBvcHRzW2tleV07XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuKGFyZ3Y6IGFueSkge1xyXG5cdGF3YWl0IGRpc3QuZW5zdXJlRG93bmxvYWRlZCgpO1xyXG5cdGlmICh1c2FnZShhcmd2KSkgcmV0dXJuIC0xO1xyXG5cdGxldCBjb25maWcgPSBpbml0Q29uZmlnKCk7XHJcblx0aWYgKGFyZ3YuYiB8fCBhcmd2LmJ1aWxkKSB7XHJcblx0XHRhd2FpdCBidWlsZChjb25maWcpO1xyXG5cdH0gZWxzZSBpZiAoYXJndi5pIHx8IGFyZ3YuaW5zdGFsbCkge1xyXG5cdFx0bGV0IGN3ZCA9IHByb2Nlc3MuY3dkKCk7XHJcblx0XHRsZXQgciA9IGN3ZC5pbmRleE9mKCdub2RlX21vZHVsZXMnKTtcclxuXHRcdGlmIChyIDwgMCkge1xyXG5cdFx0XHRjb25zb2xlLmxvZygnZG9ub3QgaW5zdGFsbCB3aGVuIHByb2Nlc3MuY3dkIGluIHRoaXMgcHJvamVjdCEhIScpO1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGF3YWl0IGluc3RhbGwoY29uZmlnKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKGFyZ3YucCB8fCBhcmd2LnBhY2spIHtcclxuXHRcdGF3YWl0IHBhY2soY29uZmlnKTtcclxuXHR9IGVsc2UgaWYgKGFyZ3YuciB8fCBhcmd2LnJlbGVhc2UpIHtcclxuXHRcdGF3YWl0IHJlbGVhc2UoY29uZmlnKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y29uc29sZS5sb2coJ2N4Yjogc2hvdyBoZWxwIHdpdGggLS1oZWxwJyk7XHJcblx0XHRyZXR1cm4gLTI7XHJcblx0fVxyXG5cdHJldHVybiAwO1xyXG5cdC8vaW5zdGFsbCgnaHR0cHM6Ly9wYXNzb2EtZ2VuZXJpYy5wa2cuY29kaW5nLm5ldC9saWJidC9saWJidC9tYXN0ZXI/dmVyc2lvbj1sYXRlc3QnLCAnJyk7XHJcbn1cclxuZnVuY3Rpb24gdXNhZ2UoYXJndjogYW55KSB7XHJcblx0bGV0IGhlbHAgPSBhcmd2LmggfHwgYXJndi5oZWxwO1xyXG5cdGlmIChoZWxwKSB7XHJcblx0XHQvLyBJZiB0aGV5IGRpZG4ndCBhc2sgZm9yIGhlbHAsIHRoZW4gdGhpcyBpcyBub3QgYSBcInN1Y2Nlc3NcIlxyXG5cdFx0dmFyIGxvZyA9IGhlbHAgPyBjb25zb2xlLmxvZyA6IGNvbnNvbGUuZXJyb3I7XHJcblx0XHRsb2coJ1VzYWdlOiBwbSA8bW9kdWxlcz4gWzxPcHRpb25zPiAuLi5dJyk7XHJcblx0XHRsb2coJycpO1xyXG5cdFx0bG9nKCcgIGluc3RhbGwgbmF0aXZlIG1vZHVsZXNAcGFzc29hJyk7XHJcblx0XHRsb2coJycpO1xyXG5cdFx0bG9nKCdPcHRpb25zOicpO1xyXG5cdFx0bG9nKCcnKTtcclxuXHRcdGxvZygnICAtaCwgLS1oZWxwICAgICBEaXNwbGF5IHRoaXMgdXNhZ2UgaW5mbycpO1xyXG5cdFx0bG9nKCcgIC1iLCAtLWJ1aWxkICAgYnVpbGQgY3BwIGZvciBwcm9qZWN0Jyk7XHJcblx0XHRsb2coJyAgLXIsIC0tcmVsZWFzZSAgIHJlbGVhc2Ugbm9kZSB0Z3ogZm9yIHByb2plY3QnKTtcclxuXHRcdGxvZygnICAtaSwgLS1pbnN0YWxsICAgaW5zdGFsbCBjcHAgbW9kdWxlKGl0IHdpbGwgYnVpbGQgY3BwIG1vZHVsZSBpZiBjb3VsZCBub3QgZG93bmxvYWQgZnJvbSByZW1vdGUpJyk7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cdHJldHVybiAwO1xyXG59XHJcbmZ1bmN0aW9uIGV2YWxfdGVtcGxhdGUodGVtcGxhdGU6IHN0cmluZywgb3B0czogYW55KSB7XHJcblx0dGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW2EtekEtWjAtOV8tXSspXFx9L2csIChzdHI6IHN0cmluZywgLi4uYXJnczogYW55W10pOiBzdHJpbmcgPT4ge1xyXG5cdFx0bGV0IGtleSA9IG9wdHNbYXJnc1swXV0gfHwgcHJvY2Vzcy5lbnZbYXJnc1swXV0gfHwgJ3VuZGVmaW5lZCc7XHJcblx0XHRyZXR1cm4ga2V5O1xyXG5cdH0pO1xyXG5cdC8vIE9iamVjdC5rZXlzKG9wdHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0Ly8gXHR2YXIgcGF0dGVybiA9ICd7JyArIGtleSArICd9JztcclxuXHQvLyBcdHdoaWxlICh0ZW1wbGF0ZS5pbmRleE9mKHBhdHRlcm4pID4gLTEpIHtcclxuXHQvLyBcdFx0dGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKHBhdHRlcm4sIG9wdHNba2V5XSk7XHJcblx0Ly8gXHR9XHJcblx0Ly8gfSk7XHJcblx0cmV0dXJuIHRlbXBsYXRlO1xyXG59XHJcblxyXG4vLyB1cmwucmVzb2x2ZSBuZWVkcyBzaW5nbGUgdHJhaWxpbmcgc2xhc2hcclxuLy8gdG8gYmVoYXZlIGNvcnJlY3RseSwgb3RoZXJ3aXNlIGEgZG91YmxlIHNsYXNoXHJcbi8vIG1heSBlbmQgdXAgaW4gdGhlIHVybCB3aGljaCBicmVha3MgcmVxdWVzdHNcclxuLy8gYW5kIGEgbGFja2luZyBzbGFzaCBtYXkgbm90IGxlYWQgdG8gcHJvcGVyIGpvaW5pbmdcclxuZnVuY3Rpb24gZml4X3NsYXNoZXMocGF0aG5hbWU6IHN0cmluZykge1xyXG5cdGlmIChwYXRobmFtZS5zbGljZSgtMSkgIT0gJy8nKSB7XHJcblx0XHRyZXR1cm4gcGF0aG5hbWUgKyAnLyc7XHJcblx0fVxyXG5cdHJldHVybiBwYXRobmFtZTtcclxufVxyXG5cclxuLy8gcmVtb3ZlIGRvdWJsZSBzbGFzaGVzXHJcbi8vIG5vdGU6IHBhdGgubm9ybWFsaXplIHdpbGwgbm90IHdvcmsgYmVjYXVzZVxyXG4vLyBpdCB3aWxsIGNvbnZlcnQgZm9yd2FyZCB0byBiYWNrIHNsYXNoZXNcclxuZnVuY3Rpb24gZHJvcF9kb3VibGVfc2xhc2hlcyhwYXRobmFtZTogc3RyaW5nKSB7XHJcblx0cmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwbGF0X2Zvcm1hdChwbGF0OiBzdHJpbmcpIHtcclxuXHRzd2l0Y2ggKHBsYXQpIHtcclxuXHRcdGNhc2UgJ3dpbjMyJzpcclxuXHRcdGNhc2UgJ3dpbmRvd3MnOlxyXG5cdFx0XHRyZXR1cm4gJ3dpbmRvd3MnO1xyXG5cdH1cclxuXHRyZXR1cm4gcGxhdDtcclxufVxyXG5mdW5jdGlvbiBhcmNoX2Zvcm1hdChhcmNoOiBzdHJpbmcpIHtcclxuXHRzd2l0Y2ggKGFyY2gpIHtcclxuXHRcdGNhc2UgJ2lhMzInOlxyXG5cdFx0Y2FzZSAneDMyJzpcclxuXHRcdGNhc2UgJ3g4Nic6XHJcblx0XHRcdHJldHVybiAneDg2JztcclxuXHRcdGNhc2UgJ3g4Nl82NCc6XHJcblx0XHRjYXNlICd4NjQnOlxyXG5cdFx0XHRyZXR1cm4gJ3g2NCc7XHJcblx0fVxyXG5cdHJldHVybiBhcmNoO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RyaW5nQXJyYXkoYXJyOiBhbnlbXSkge1xyXG5cdGZvciAoY29uc3QgaXRlcmF0b3Igb2YgYXJyKSB7XHJcblx0XHRpZiAodHlwZW9mIGl0ZXJhdG9yICE9ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RyaW5nQXJyYXkyKGFycjogYW55W10pIHtcclxuXHRmb3IgKGNvbnN0IGl0ZXJhdG9yIG9mIGFycikge1xyXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGl0ZXJhdG9yKSAmJiAhaXNTdHJpbmdBcnJheShpdGVyYXRvcikpIHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gYWRkRGVmYXVsdENtZChiYzogc3RyaW5nW10sIGNvbmZpZzogQ29uZmlnT2JqZWN0KSB7XHJcblx0bGV0IGluY1BhdGhzO1xyXG5cdGlmIChkaXN0LmhlYWRlck9ubHkpIHtcclxuXHRcdGluY1BhdGhzID0gWyBwYXRoLmpvaW4oZGlzdC5pbnRlcm5hbFBhdGgsICcvaW5jbHVkZS9ub2RlJykgXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bGV0IG5vZGVIID0gcGF0aC5qb2luKGRpc3QuaW50ZXJuYWxQYXRoLCAnL3NyYycpO1xyXG5cdFx0bGV0IHY4SCA9IHBhdGguam9pbihkaXN0LmludGVybmFsUGF0aCwgJy9kZXBzL3Y4L2luY2x1ZGUnKTtcclxuXHRcdGxldCB1dkggPSBwYXRoLmpvaW4oZGlzdC5pbnRlcm5hbFBhdGgsICcvZGVwcy91di9pbmNsdWRlJyk7XHJcblx0XHRpbmNQYXRocyA9IFsgbm9kZUgsIHY4SCwgdXZIIF07XHJcblx0fVxyXG5cdC8vIEluY2x1ZGVzOlxyXG5cdGJjLnB1c2goYC1EQ01BS0VfSlNfSU5DPSR7aW5jUGF0aHMuam9pbignOycpfWApO1xyXG5cdGlmIChlbnZpcm9ubWVudC5pc1dpbikge1xyXG5cdFx0Ly8gV2luXHJcblx0XHRsZXQgbGlicyA9IGRpc3Qud2luTGlicztcclxuXHRcdGlmIChsaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRiYy5wdXNoKGAtRENNQUtFX0pTX0xJQj0ke2xpYnMuam9pbignOycpfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRiYy5wdXNoKGAtRENYQl9NT0RVTEVfRElTVD0ke2NvbmZpZy5yb290X2Rpcn0vJHtjb25maWcubW9kdWxlX3BhdGh9YCk7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRCeVN0cmluZ0FycmF5KGJ1aWxkX3N0cjogc3RyaW5nLCBjb25maWc6IENvbmZpZ09iamVjdCwgYmM6IHN0cmluZ1tdKSB7XHJcblx0Zm9yIChjb25zdCBrZXkgaW4gYmMpIHtcclxuXHRcdGlmIChiYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0XHRcdGNvbnN0IGVsZW1lbnQgPSBiY1trZXldO1xyXG5cdFx0XHRiY1trZXldID0gZXZhbF90ZW1wbGF0ZShlbGVtZW50LCBjb25maWcpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnMuZW1wdHlEaXJTeW5jKGB0bXAvJHtidWlsZF9zdHJ9YCk7XHJcblx0cHJvY2Vzcy5jaGRpcihgdG1wLyR7YnVpbGRfc3RyfWApO1xyXG5cclxuXHRiYyA9IFsgJy4uLy4uLycgXS5jb25jYXQoYmMpO1xyXG5cdGFkZERlZmF1bHRDbWQoYmMsIGNvbmZpZyk7XHJcblx0Y29uc29sZS5sb2coYmMpO1xyXG5cclxuXHRsZXQgciA9IGNwLnNwYXduU3luYygnY21ha2UnLCBiYywgeyBzdGRpbzogJ2luaGVyaXQnIH0pO1xyXG5cdGlmIChyLnN0YXR1cykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdjbWFrZSBnZW5lcmF0b3IgZmFpbHMnKTtcclxuXHR9XHJcblx0ciA9IGNwLnNwYXduU3luYygnY21ha2UnLCBbICctLWJ1aWxkJywgJy4vJywgJy0tY29uZmlnJywgY29uZmlnLmNvbmZpZ3VyYXRpb24gXSwgeyBzdGRpbzogJ2luaGVyaXQnIH0pO1xyXG5cdGlmIChyLnN0YXR1cykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdjbWFrZSBidWlsZCBmYWlscycpO1xyXG5cdH1cclxuXHRwcm9jZXNzLmNoZGlyKCcuLi8uLi8nKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkKGNvbmZpZzogQ29uZmlnT2JqZWN0KSB7XHJcblx0aWYgKGNvbmZpZy5leHRlcm5hbCkge1xyXG5cdFx0bGV0IHRhc2sxID0gbmV3IEFycmF5PGlmS3k+KCksXHJcblx0XHRcdHRhc2syID0gbmV3IEFycmF5PGlmS3k+KCk7XHJcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBjb25maWcuZXh0ZXJuYWwpIHtcclxuXHRcdFx0aWYgKGNvbmZpZy5leHRlcm5hbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0XHRcdFx0Y29uc3Qgb2JqID0gY29uZmlnLmV4dGVybmFsW2tleV07XHJcblx0XHRcdFx0bGV0IHVybHN0cmluZyA9ICcnO1xyXG5cdFx0XHRcdGlmIChpc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRcdHVybHN0cmluZyA9IG9ialswXTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKG9iaikpIHtcclxuXHRcdFx0XHRcdHVybHN0cmluZyA9IG9iajtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjeGIuZXh0ZXJuYWwgY29uZmlnIGhhcyBlcnJvcicpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgcGF0aG5hbWUgPSB1cmwucGFyc2UodXJsc3RyaW5nKS5wYXRobmFtZTtcclxuXHRcdFx0XHRpZiAoIXBhdGhuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ2N4Yi5leHRlcm5hbCBjb25maWcgaGFzIGVycm9yOicgKyBwYXRobmFtZSk7XHJcblx0XHRcdFx0bGV0IHRtcCA9IGAke2NvbmZpZy5yb290X2Rpcn0vdG1wL3N0YWdlLyR7a2V5fS8ke3BhdGguYmFzZW5hbWUocGF0aG5hbWUpfWA7XHJcblx0XHRcdFx0bGV0IGRzdCA9IHBhdGguam9pbihgJHtjb25maWcucm9vdF9kaXJ9LzNyZGAsIGtleSk7XHJcblxyXG5cdFx0XHRcdGlmIChmcy5leGlzdHNTeW5jKGRzdCkpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zb2xlLmxvZyh1cmxzdHJpbmcsIHRtcCk7XHJcblx0XHRcdFx0dGFzazEucHVzaCh7IHNyYzogdXJsc3RyaW5nLCBkc3Q6IHRtcCB9KTtcclxuXHRcdFx0XHR0YXNrMi5wdXNoKHsgc3JjOiB0bXAsIGRzdDogZHN0LCBvcHRpb246IHsgc3RyaXA6IG9ialsxXSB9IH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRhd2FpdCBkb3dubG9hZGVyLmRvd25sb2FkQWxsKHRhc2sxKTtcclxuXHRcdGF3YWl0IGRvd25sb2FkZXIudW56aXBBbGwodGFzazIpO1xyXG5cdH1cclxuXHRpZiAoY29uZmlnLmJ1aWxkX2NtZCkge1xyXG5cdFx0bGV0IGJ1aWxkX3N0ciA9IGAke2NvbmZpZy5wbGF0Zm9ybX1fJHtjb25maWcuYXJjaH1gO1xyXG5cdFx0bGV0IGJjID0gY29uZmlnLmJ1aWxkX2NtZFtidWlsZF9zdHJdO1xyXG5cdFx0aWYgKCFiYykge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHBsZWFzZSBjaGVjayB5b3VyIGNvbmZpZyBmb3IgJHtidWlsZF9zdHJ9YCk7XHJcblx0XHR9XHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShiYykpIHtcclxuXHRcdFx0aWYgKGlzU3RyaW5nQXJyYXkoYmMpKSB7XHJcblx0XHRcdFx0YnVpbGRCeVN0cmluZ0FycmF5KGJ1aWxkX3N0ciwgY29uZmlnLCBiYyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNTdHJpbmdBcnJheTIoYmMpKSB7XHJcblx0XHRcdFx0bGV0IGlkeCA9IDA7XHJcblx0XHRcdFx0Zm9yIChjb25zdCBpdGVyYXRvciBvZiBiYykge1xyXG5cdFx0XHRcdFx0YnVpbGRCeVN0cmluZ0FycmF5KGAke2J1aWxkX3N0cn1fJHtpZHgrK31gLCBjb25maWcsIGl0ZXJhdG9yKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBwbGVhc2UgY2hlY2sgeW91ciBjb25maWcgZm9yICR7YnVpbGRfc3RyfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignYnVpbGRfY21kIGhhcyBub3QgaW4gY3hiLmNvbmZpZy5qcycpO1xyXG5cdH1cclxuXHRyZXR1cm4gMDtcclxufVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5zdGFsbChjb25maWc6IENvbmZpZ09iamVjdCkge1xyXG5cdGxldCB0YXJiYWxsID0gYCR7Y29uZmlnLm1vZHVsZV9uYW1lfS12JHtjb25maWcudmVyc2lvbn0tJHtjb25maWcucGxhdGZvcm19LSR7Y29uZmlnLmFyY2h9LnRhci5nemA7XHJcblx0Y29uZmlnLnN0YWdlZF90YXJiYWxsID0gcGF0aC5qb2luKCd0bXAvc3RhZ2UnLCB0YXJiYWxsKTtcclxuXHR0cnkge1xyXG5cdFx0YXdhaXQgZG93bmxvYWRlci5kb3dubG9hZEFsbChbIHsgc3JjOiBjb25maWcuaG9zdGVkX3RhcmJhbGwsIGRzdDogY29uZmlnLnN0YWdlZF90YXJiYWxsIH0gXSk7XHJcblx0XHRhd2FpdCBkb3dubG9hZGVyLnVuemlwQWxsKFsgeyBzcmM6IGNvbmZpZy5zdGFnZWRfdGFyYmFsbCwgZHN0OiAnLi8nIH0gXSk7XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRjb25zb2xlLmxvZyhjb25maWcuaG9zdGVkX3RhcmJhbGwpO1xyXG5cdFx0Y29uc29sZS5sb2coZXJyLm1lc3NhZ2UpO1xyXG5cdFx0cmV0dXJuIGJ1aWxkKGNvbmZpZyk7XHJcblx0fVxyXG5cdHJldHVybiAwO1xyXG5cdC8vIGlmIChhd2FpdCBkb3dubG9hZChjb25maWcuaG9zdGVkX3RhcmJhbGwsIGNvbmZpZy5zdGFnZWRfdGFyYmFsbCkpIHtcclxuXHQvLyBcdGZzLnJlbW92ZVN5bmMoY29uZmlnLnN0YWdlZF90YXJiYWxsKTtcclxuXHQvLyBcdHRocm93IG5ldyBFcnJvcihgZG93bmxvYWQgJHtjb25maWcuaG9zdGVkX3RhcmJhbGx9IGVycm9yIGluIGluc3RhbGxgKTtcclxuXHQvLyB9XHJcblx0Ly8gaWYgKGF3YWl0IHVuY29tcHJlc3MoY29uZmlnLnN0YWdlZF90YXJiYWxsLCBjb25maWcubW9kdWxlX3BhdGgpKSB7XHJcblx0Ly8gXHRmcy5yZW1vdmVTeW5jKGNvbmZpZy5zdGFnZWRfdGFyYmFsbCk7XHJcblx0Ly8gXHR0aHJvdyBuZXcgRXJyb3IoYHVuY29tcHJlc3MgJHtjb25maWcuc3RhZ2VkX3RhcmJhbGx9IGVycm9yIGluIGluc3RhbGxgKTtcclxuXHQvLyB9XHJcbn1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbGVhc2UoY29uZmlnOiBDb25maWdPYmplY3QpIHtcclxuXHRsZXQgdXAgPSBuZXcgVXBsb2FkZXIoKTtcclxuXHRsZXQgc3JjID0gcGF0aC5qb2luKGNvbmZpZy5yb290X2RpciwgY29uZmlnLm1vZHVsZV9wYXRoKTtcclxuXHRjb25maWcuc3RhZ2VkX3RhcmJhbGwgPSBwYXRoLmpvaW4oY29uZmlnLnJvb3RfZGlyLCBgdG1wLyR7Y29uZmlnLm1vZHVsZV9uYW1lfS50YXIuZ3pgKTtcclxuXHRhd2FpdCB1cC5wYWNrVGd6KHNyYywgY29uZmlnLnN0YWdlZF90YXJiYWxsKTtcclxuXHRsZXQgZW52ID0gcHJvY2Vzcy5lbnY7XHJcblx0Y29uZmlnLnRva2VuID0gQnVmZmVyLmZyb20oYCR7ZW52LkNYQlVTRVJOQU1FfToke2Vudi5DWEJQQVNTV09SRH1gLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuXHRhd2FpdCB1cC51cGxvYWQoY29uZmlnLmhvc3RlZF90YXJiYWxsLCBjb25maWcuc3RhZ2VkX3RhcmJhbGwsIGNvbmZpZy50b2tlbiwge1xyXG5cdFx0bWV0aG9kOiBjb25maWcubWV0aG9kLFxyXG5cdFx0Zm9ybTogY29uZmlnLmZvcm1cclxuXHR9KTtcclxuXHRyZXR1cm4gMDtcclxufVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFjayhjb25maWc6IENvbmZpZ09iamVjdCkge1xyXG5cdGxldCB1cCA9IG5ldyBVcGxvYWRlcigpO1xyXG5cdGxldCBzcmMgPSBwYXRoLmpvaW4oY29uZmlnLnJvb3RfZGlyLCBjb25maWcubW9kdWxlX3BhdGgpO1xyXG5cdGNvbmZpZy5zdGFnZWRfdGFyYmFsbCA9IHBhdGguam9pbihjb25maWcucm9vdF9kaXIsIGB0bXAvJHtjb25maWcubW9kdWxlX25hbWV9LnRhci5nemApO1xyXG5cdHJldHVybiBhd2FpdCB1cC5wYWNrVGd6KHNyYywgY29uZmlnLnN0YWdlZF90YXJiYWxsKTtcclxufVxyXG4iXX0=